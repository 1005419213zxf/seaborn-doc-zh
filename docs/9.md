# 选择配色方案

颜色在图像风格中比起其他元素显得更为重要。当合理有效地使用颜色时，数据模式会被凸显出来；反之，则会被掩盖。这里有很多数据可视化中关于颜色使用的优秀资源，我推荐阅读这些 Rob Simmon 的[博客文章](https://earthobservatory.nasa.gov/blogs/elegantfigures/2013/08/05/subtleties-of-color-part-1-of-6/) 以及这篇更加学术性的[论文](https://cfwebprod.sandia.gov/cfdocs/CompResearch/docs/ColorMapsExpanded.pdf)。 此外，matplotlib 文档也提供了一篇很好的[教程](https://matplotlib.org/users/colormaps.html)来说明一些内置色彩映射的感知属性。

Seaborn让您在选择与您处理的数据和可视化过程中搭配的配色方案变得简单。

```py
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
sns.set()

```

## 创建配色方案

使用离散调色板过程中最重要函数是[`color_palette()`](../generated/seaborn.color_palette.html#seaborn.color_palette "seaborn.color_palette")。这个函数为许多(但不是全部)可以在seborn中生成颜色的方式提供了一个接口，并且在任何具有`palette`参数的函数的内部都可以使用(以及某些需要多种颜色时具有`color`参数的情况)。

[`color_palette()`](../generated/seaborn.color_palette.html#seaborn.color_palette "seaborn.color_palette") 会接受所有的serborn配色方案或者matplotlib色彩映射 (除了 `jet`, 您永远都不应该使用它). 它还可以获取以任何有效matplotlib格式(RGB元组、十六进制颜色代码或HTML颜色名字)指定的颜色列表。返回值始终是RGB元组的列表。

最后，在没有参数的情况下调用[`color_palette()`](../generated/seaborn.color_palette.html#seaborn.color_palette "seaborn.color_palette")函数将会返回当前默认的颜色循环。

函数[`set_palette()`](../generated/seaborn.set_palette.html#seaborn.set_palette "seaborn.set_palette")接受相同的参数，并将为所有点设置默认的颜色循环。您也可以在`with`语句中调用[`color_palette()`](../generated/seaborn.color_palette.html#seaborn.color_palette "seaborn.color_palette")来临时改变配色方案。([参见](#palette-contexts))

在不了解数据特征的情况下，通常不可能知道哪种配色方案或色彩映射最适合一组数据。接下来，我们将通过三种常见的配色方案 _qualitative_, _sequential_, 和 _diverging_ 来拆分介绍使用[`color_palette()`](../generated/seaborn.color_palette.html#seaborn.color_palette "seaborn.color_palette")的不同方法以及其他seaborn函数。

## Qualitative color palettes

当您想要区分不具有内在顺序的离散数据块时，Qualitative (or categorical) palettes是最佳方案。

导入Seaborn的同时，会引入默认的颜色循环，由6种颜色构成。并将唤起标准matplotlib颜色循环，看起来也更加赏心悦目。

```py
current_palette = sns.color_palette()
sns.palplot(current_palette)

```

![http://seaborn.pydata.org/_images/color_palettes_6_0.png](img/975109fd603a63c12f7e0db1461d265e.jpg)

默认主题有六种变体，分别为`deep`, `muted`, `pastel`, `bright`, `dark`, and `colorblind`。

![http://seaborn.pydata.org/_images/color_palettes_8_0.png](img/9dee4b50342228bbf515be6a3e60b0e8.jpg)

### 使用循环颜色系统

当您要区分任意数量的类别而不强调任何类别时，最简单的方法是在圆形颜色空间中绘制间距相等的颜色(在此颜色空间中，色调会发生变化，同时保持亮度和饱和度不变)。这是大多数seaborn函数在处理当需要区分的数据集超过颜色循环中的6种颜色时时所使用的默认方法。

最为常用的方法是使用`hls‘颜色空间——一种简单的RGB值变体。

```py
sns.palplot(sns.color_palette("hls", 8))

```

![http://seaborn.pydata.org/_images/color_palettes_10_0.png](img/f35d431e80f906b39aa82e1bd8390361.jpg)

[`hls_palette()`](../generated/seaborn.hls_palette.html#seaborn.hls_palette "seaborn.hls_palette")函数允许您控制颜色的亮度和饱和度。

```py
sns.palplot(sns.hls_palette(8, l=.3, s=.8))

```

![http://seaborn.pydata.org/_images/color_palettes_12_0.png](img/7787cf3ad144a10c16ce1f2697d4af34.jpg)

然而，由于人类视觉系统的工作方式，RGB强度很高的颜色也不一定看起来同样强烈。[我们认为](https://en.wikipedia.org/wiki/Color_vision)黄色和绿色是相对较亮的，蓝色是相对较暗的，当目标是与`hls`系统保持一致性时可能会带来一些问题。

为了解决这一问题，seborn提供了一个[husl](http://www.hsluv.org/)系统(后来更名为HSLuv)的接口，这也使选择间隔均匀的色调变得容易，同时使外观亮度和饱和度都更加均匀。

```py
sns.palplot(sns.color_palette("husl", 8))

```

![http://seaborn.pydata.org/_images/color_palettes_14_0.png](img/151c643774e7ae51ed523abe3fa5f559.jpg)

类似地，还有一个名为[`husl_palette()`](../generated/seaborn.husl_palette.html#seaborn.husl_palette "seaborn.husl_palette")的函数，它为这个系统提供了一个更灵活的接口。

### 使用Color Brewer调色板

[Color Brewer](http://colorbrewer2.org/)是另一个提供好看的配色方案(包括sequential palettes和 diverging palettes，详情见下文)。这些也作为matplotlib色彩映射存在，但并没有得到很好的处理。在seaborn中，当您需要定性(qualitative)的Color Brewer方案时，你总是会得到离散的颜色，但这意味着在某些情况下颜色会循环重复。

Color Brewer网站的一个很好的特点是它对色盲比较友好。[色盲](https：/en.wikipea.org/wiki/Color_Blinity)有很多种，最为常见的是红绿色盲。通常，对于需要根据颜色进行区分元素时，尽量避免使用红色和绿色是一个好主意。

```py
sns.palplot(sns.color_palette("Paired"))

```

![http://seaborn.pydata.org/_images/color_palettes_16_0.png](img/4a2b106cd5abd71c514edda6c1f06b6e.jpg)

```py
sns.palplot(sns.color_palette("Set2"))

```

![http://seaborn.pydata.org/_images/color_palettes_17_0.png](img/8d928f7a998a90772bc3defd036444a8.jpg)

为了帮助您从Color Brewer库中选取配色方案，seaborn提供了[`choose_colorbrewer_palette()`](../generated/seaborn.choose_colorbrewer_palette.html#seaborn.choose_colorbrewer_palette "seaborn.choose_colorbrewer_palette")函数。这个函数能够启动交互式组件来帮助您浏览各种选项，修改不同的参数。但是只能在Jupyter notebook中使用。

当然，您可能只希望手动指定一组您喜欢的颜色。[`color_palette()`](../generated/seaborn.color_palette.html#seaborn.color_palette "seaborn.color_palette")接受一个颜色列表，操作起来也很简单。

```py
flatui = ["#9b59b6", "#3498db", "#95a5a6", "#e74c3c", "#34495e", "#2ecc71"]
sns.palplot(sns.color_palette(flatui))

```

![http://seaborn.pydata.org/_images/color_palettes_19_0.png](img/e1506db895aa2aaa0d7df99cc7d3d4c3.jpg)

### 使用来自xkcd color survey的颜色名字

不久前，[xkcd](https://xkcd.com/)开展了一项[众包工作](https://blog.xkcd.com/2010/05/03/color-survey-results/)来为随机RGB颜色命名。产生了[954个颜色名字](https://xkcd.com/color/rgb/)，您现在可以在seaborn中使用`xkcd_rgb`字典来引用它：

```py
plt.plot([0, 1], [0, 1], sns.xkcd_rgb["pale red"], lw=3)
plt.plot([0, 1], [0, 2], sns.xkcd_rgb["medium green"], lw=3)
plt.plot([0, 1], [0, 3], sns.xkcd_rgb["denim blue"], lw=3);

```

![http://seaborn.pydata.org/_images/color_palettes_21_0.png](img/85ba77533a6b6eb1cc44b5bf4aed4e1d.jpg)

除了从`xkcd_rgb`字典中提取单一颜色外，您也可以向[`xkcd_palette()`](../generated/seaborn.xkcd_palette.html#seaborn.xkcd_palette "seaborn.xkcd_palette")函数传递一个颜色名称列表。

```py
colors = ["windows blue", "amber", "greyish", "faded green", "dusty purple"]
sns.palplot(sns.xkcd_palette(colors))

```

![http://seaborn.pydata.org/_images/color_palettes_23_0.png](img/6508f97c0a5563f99b755ccfac8c2b12.jpg)

## Sequential color palettes

The second major class of color palettes is called “sequential”. This kind of color mapping is appropriate when data range from relatively low or uninteresting values to relatively high or interesting values. Although there are cases where you will want discrete colors in a sequential palette, it’s more common to use them as a colormap in functions like [`kdeplot()`](../generated/seaborn.kdeplot.html#seaborn.kdeplot "seaborn.kdeplot") and [`heatmap()`](../generated/seaborn.heatmap.html#seaborn.heatmap "seaborn.heatmap") (along with similar matplotlib functions).

It’s common to see colormaps like `jet` (or other rainbow palettes) used in this case, because the range of hues gives the impression of providing additional information about the data. However, colormaps with large hue shifts tend to introduce discontinuities that don’t exist in the data, and our visual system isn’t able to naturally map the rainbow to quantitative distinctions like “high” or “low”. The result is that these visualizations end up being more like a puzzle, and they obscure patterns in the data rather than revealing them. The jet palette is because the brightest colors, yellow and cyan, are used for intermediate data values. This has the effect of emphasizing uninteresting (and arbitrary) values while deemphasizing the extremes.

For sequential data, it’s better to use palettes that have at most a relatively subtle shift in hue accompanied by a large shift in brightness and saturation. This approach will naturally draw the eye to the relatively important parts of the data.

The Color Brewer library has a great set of these palettes. They’re named after the dominant color (or colors) in the palette.

```py
sns.palplot(sns.color_palette("Blues"))

```

![http://seaborn.pydata.org/_images/color_palettes_25_0.png](img/b6ac2dda5753920442b42aa6c3f8746c.jpg)

Like in matplotlib, if you want the lightness ramp to be reversed, you can add a `_r` suffix to the palette name.

```py
sns.palplot(sns.color_palette("BuGn_r"))

```

![http://seaborn.pydata.org/_images/color_palettes_27_0.png](img/35ba6c0dab54401105c2b869de17084b.jpg)

Seaborn also adds a trick that allows you to create “dark” palettes, which do not have as wide a dynamic range. This can be useful if you want to map lines or points sequentially, as brighter-colored lines might otherwise be hard to distinguish.

```py
sns.palplot(sns.color_palette("GnBu_d"))

```

![http://seaborn.pydata.org/_images/color_palettes_29_0.png](img/12d91b101a0391d48ce055f66e4a910a.jpg)

Remember that you may want to use the [`choose_colorbrewer_palette()`](../generated/seaborn.choose_colorbrewer_palette.html#seaborn.choose_colorbrewer_palette "seaborn.choose_colorbrewer_palette") function to play with the various options, and you can set the `as_cmap` argument to `True` if you want the return value to be a colormap object that you can pass to seaborn or matplotlib functions.

### Sequential “cubehelix” palettes

The [cubehelix](https://www.mrao.cam.ac.uk/~dag/CUBEHELIX/) color palette system makes sequential palettes with a linear increase or decrease in brightness and some variation in hue. This means that the information in your colormap will be preserved when converted to black and white (for printing) or when viewed by a colorblind individual.

Matplotlib has the default cubehelix version built into it:

```py
sns.palplot(sns.color_palette("cubehelix", 8))

```

![http://seaborn.pydata.org/_images/color_palettes_32_0.png](img/d07b38f860b0f58e365e7ea26da8be92.jpg)

Seaborn adds an interface to the cubehelix _system_ so that you can make a variety of palettes that all have a well-behaved linear brightness ramp.

The default palette returned by the seaborn [`cubehelix_palette()`](../generated/seaborn.cubehelix_palette.html#seaborn.cubehelix_palette "seaborn.cubehelix_palette") function is a bit different from the matplotlib default in that it does not rotate as far around the hue wheel or cover as wide a range of intensities. It also reverses the order so that more important values are darker:

```py
sns.palplot(sns.cubehelix_palette(8))

```

![http://seaborn.pydata.org/_images/color_palettes_34_0.png](img/be20ca200667c3c8849b95c4a6aa846e.jpg)

Other arguments to [`cubehelix_palette()`](../generated/seaborn.cubehelix_palette.html#seaborn.cubehelix_palette "seaborn.cubehelix_palette") control how the palette looks. The two main things you’ll change are the `start` (a value between 0 and 3) and `rot`, or number of rotations (an arbitrary value, but probably within -1 and 1),

```py
sns.palplot(sns.cubehelix_palette(8, start=.5, rot=-.75))

```

![http://seaborn.pydata.org/_images/color_palettes_36_0.png](img/e4e79afcca0586e526385c901b5cf806.jpg)

You can also control how dark and light the endpoints are and even reverse the ramp:

```py
sns.palplot(sns.cubehelix_palette(8, start=2, rot=0, dark=0, light=.95, reverse=True))

```

![http://seaborn.pydata.org/_images/color_palettes_38_0.png](img/c4e8f173e5519de01ed11bca06911371.jpg)

By default you just get a list of colors, like any other seaborn palette, but you can also return the palette as a colormap object that can be passed to seaborn or matplotlib functions using `as_cmap=True`.

```py
x, y = np.random.multivariate_normal([0, 0], [[1, -.5], [-.5, 1]], size=300).T
cmap = sns.cubehelix_palette(light=1, as_cmap=True)
sns.kdeplot(x, y, cmap=cmap, shade=True);

```

![http://seaborn.pydata.org/_images/color_palettes_40_0.png](img/2e48cfc09dde0559e31096f5a067ad3d.jpg)

To help select good palettes or colormaps using this system, you can use the [`choose_cubehelix_palette()`](../generated/seaborn.choose_cubehelix_palette.html#seaborn.choose_cubehelix_palette "seaborn.choose_cubehelix_palette") function in a notebook to launch an interactive app that will let you play with the different parameters. Pass `as_cmap=True` if you want the function to return a colormap (rather than a list) for use in function like `hexbin`.

### Custom sequential palettes

For a simpler interface to custom sequential palettes, you can use [`light_palette()`](../generated/seaborn.light_palette.html#seaborn.light_palette "seaborn.light_palette") or [`dark_palette()`](../generated/seaborn.dark_palette.html#seaborn.dark_palette "seaborn.dark_palette"), which are both seeded with a single color and produce a palette that ramps either from light or dark desaturated values to that color. These functions are also accompanied by the [`choose_light_palette()`](../generated/seaborn.choose_light_palette.html#seaborn.choose_light_palette "seaborn.choose_light_palette") and [`choose_dark_palette()`](../generated/seaborn.choose_dark_palette.html#seaborn.choose_dark_palette "seaborn.choose_dark_palette") functions that launch interactive widgets to create these palettes.

```py
sns.palplot(sns.light_palette("green"))

```

![http://seaborn.pydata.org/_images/color_palettes_43_0.png](img/c5d7ac6e8ae2f2ccf0f40dd4dccda398.jpg)

```py
sns.palplot(sns.dark_palette("purple"))

```

![http://seaborn.pydata.org/_images/color_palettes_44_0.png](img/de7d739c3094b9d34a7c69356ed9703f.jpg)

These palettes can also be reversed.

```py
sns.palplot(sns.light_palette("navy", reverse=True))

```

![http://seaborn.pydata.org/_images/color_palettes_46_0.png](img/c32dd39f791f7d395dc47b37e1252b78.jpg)

They can also be used to create colormap objects rather than lists of colors.

```py
pal = sns.dark_palette("palegreen", as_cmap=True)
sns.kdeplot(x, y, cmap=pal);

```

![http://seaborn.pydata.org/_images/color_palettes_48_0.png](img/16096f5a5796354b892ba4f6ff2dcef1.jpg)

By default, the input can be any valid matplotlib color. Alternate interpretations are controlled by the `input` argument. Currently you can provide tuples in `hls` or `husl` space along with the default `rgb`, and you can also seed the palette with any valid `xkcd` color.

```py
sns.palplot(sns.light_palette((210, 90, 60), input="husl"))

```

![http://seaborn.pydata.org/_images/color_palettes_50_0.png](img/697bc3366186ebc63715159c7e6f934a.jpg)

```py
sns.palplot(sns.dark_palette("muted purple", input="xkcd"))

```

![http://seaborn.pydata.org/_images/color_palettes_51_0.png](img/eaa5d2a866409544e7f4f2f2b484e4f5.jpg)

Note that the default input space for the interactive palette widgets is `husl`, which is different from the default for the function itself, but much more useful in this context.

## Diverging color palettes

The third class of color palettes is called “diverging”. These are used for data where both large low and high values are interesting. There is also usually a well-defined midpoint in the data. For instance, if you are plotting changes in temperature from some baseline timepoint, it is best to use a diverging colormap to show areas with relative decreases and areas with relative increases.

The rules for choosing good diverging palettes are similar to good sequential palettes, except now you want to have two relatively subtle hue shifts from distinct starting hues that meet in an under-emphasized color at the midpoint. It’s also important that the starting values are of similar brightness and saturation.

It’s also important to emphasize here that using red and green should be avoided, as a substantial population of potential viewers will be [unable to distinguish them](https://en.wikipedia.org/wiki/Color_blindness).

It should not surprise you that the Color Brewer library comes with a set of well-chosen diverging colormaps.

```py
sns.palplot(sns.color_palette("BrBG", 7))

```

![http://seaborn.pydata.org/_images/color_palettes_54_0.png](img/fb741f69016b77f7e6a93fc12ad8420c.jpg)

```py
sns.palplot(sns.color_palette("RdBu_r", 7))

```

![http://seaborn.pydata.org/_images/color_palettes_55_0.png](img/a6f00f18e0a24fee984824847391d181.jpg)

Another good choice that is built into matplotlib is the `coolwarm` palette. Note that this colormap has less contrast between the middle values and the extremes.

```py
sns.palplot(sns.color_palette("coolwarm", 7))

```

![http://seaborn.pydata.org/_images/color_palettes_57_0.png](img/650e30fa2dd7a01892cacc0fd1e2ca85.jpg)

### Custom diverging palettes

You can also use the seaborn function [`diverging_palette()`](../generated/seaborn.diverging_palette.html#seaborn.diverging_palette "seaborn.diverging_palette") to create a custom colormap for diverging data. (Naturally there is also a companion interactive widget, [`choose_diverging_palette()`](../generated/seaborn.choose_diverging_palette.html#seaborn.choose_diverging_palette "seaborn.choose_diverging_palette")). This function makes diverging palettes using the `husl` color system. You pass it two hues (in degrees) and, optionally, the lightness and saturation values for the extremes. Using `husl` means that the extreme values, and the resulting ramps to the midpoint, will be well-balanced.

```py
sns.palplot(sns.diverging_palette(220, 20, n=7))

```

![http://seaborn.pydata.org/_images/color_palettes_59_0.png](img/429c1d877c3d7c4b23d82d35ade3603d.jpg)

```py
sns.palplot(sns.diverging_palette(145, 280, s=85, l=25, n=7))

```

![http://seaborn.pydata.org/_images/color_palettes_60_0.png](img/75b405b71a445bc29d020b75ee4b3632.jpg)

The `sep` argument controls the width of the separation between the two ramps in the middle region of the palette.

```py
sns.palplot(sns.diverging_palette(10, 220, sep=80, n=7))

```

![http://seaborn.pydata.org/_images/color_palettes_62_0.png](img/df43f6b2a11e5c0ee8c60f7ef2962e19.jpg)

It’s also possible to make a palette with the midpoint is dark rather than light.

```py
sns.palplot(sns.diverging_palette(255, 133, l=60, n=7, center="dark"))

```

![http://seaborn.pydata.org/_images/color_palettes_64_0.png](img/b0fa1a625cc563e5a13abc41fa080b59.jpg)

## Setting the default color palette

The [`color_palette()`](../generated/seaborn.color_palette.html#seaborn.color_palette "seaborn.color_palette") function has a companion called [`set_palette()`](../generated/seaborn.set_palette.html#seaborn.set_palette "seaborn.set_palette"). The relationship between them is similar to the pairs covered in the [aesthetics tutorial](aesthetics.html#aesthetics-tutorial). [`set_palette()`](../generated/seaborn.set_palette.html#seaborn.set_palette "seaborn.set_palette") accepts the same arguments as [`color_palette()`](../generated/seaborn.color_palette.html#seaborn.color_palette "seaborn.color_palette"), but it changes the default matplotlib parameters so that the palette is used for all plots.

```py
def sinplot(flip=1):
    x = np.linspace(0, 14, 100)
    for i in range(1, 7):
        plt.plot(x, np.sin(x + i * .5) * (7 - i) * flip)

```

```py
sns.set_palette("husl")
sinplot()

```

![http://seaborn.pydata.org/_images/color_palettes_67_0.png](img/6c2898fe95dd4d45e166acda2ab730fe.jpg)

The [`color_palette()`](../generated/seaborn.color_palette.html#seaborn.color_palette "seaborn.color_palette") function can also be used in a `with` statement to temporarily change the color palette.

```py
with sns.color_palette("PuBuGn_d"):
    sinplot()

```

![http://seaborn.pydata.org/_images/color_palettes_69_0.png](img/a276fb7452f1f31a95ec2ec9d810fa20.jpg)